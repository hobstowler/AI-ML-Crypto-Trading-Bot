import requests


class DatastoreWrapper():
    def __init__(self, url=None):
        if url is None:
            url = 'https://datastore-micro-dot-ai-ml-bitcoin-bot.uw.r.appspot.com/'
        self.url = url
        self._stored_session = -1

    def create_session(self, **kwargs) -> int:
        """
        Creates a new session entity with the provided keyword arguments.
        Returns the resulting session_id from datastore to use in later requests.
        Required keyword arguments and types:
            session_name : str
            type : str
            starting_balance : float
            starting_coins : float
            crypto_type : str
        Refer to README for full list of keyword arguments.
        :param kwargs: Session details to be sent in the request.
        :return: The session_id upon success.
        """
        # validate inputs
        if 'session_name' not in kwargs:
            raise Exception('Missing required "session_name" in kwargs.')
        if 'type' not in kwargs:
            raise Exception('Missing required "type" in kwargs.')
        if 'starting_balance' not in kwargs:
            raise Exception('Missing required "starting_balance" in kwargs.')
        if 'starting_coins' not in kwargs:
            raise Exception('Missing required "starting_coins" in kwargs.')
        if 'crypto_type' not in kwargs:
            raise Exception('Missing required "crypto_type" in kwargs.')

        resp = requests.post(f'{self.url}/session/', json=kwargs)
        if resp.status_code == 201:
            json = resp.json()
            self._stored_session = int(json['id'])
            return self._stored_session
        else:
            raise Exception(f'response from server: {resp.status_code}')

    def get_most_recent_session_id(self) -> int:
        """
        Returns the session id of the most recently created session or -1 if no session has been created with this
        instance of the Wrapper class.
        :return: The session id of the most recently created session.
        """
        return self._stored_session

    def get_all_sessions(self) -> list:
        """
        Returns all sessions from datatstore as a list. If a field has not been valued via POST or PATCH, it will be
        returned as None.
        :return: a list of session entities from datastore.
        """
        resp = requests.get(f'{self.url}/session')
        if resp.status_code == 200:
            json = resp.json()['sessions']
            return json
        else:
            raise Exception(f'response from server: {resp.status_code}')

    def get_session_by_id(self, session_id: int = None) -> dict:
        """
        Returns a session for a given session_id. Session_id can be obtained when creating a session or by searching
        the list of all sessions returned from get_all_sessions(). The DatastoreWrapper class will also store the
        session_id of most recently created session, which can be retrieved with the get_most_recent_session_id()
        method.
        :param session_id: A unique ID generated by datastore used to identify a particular session.
        :return: A session with the given session ID.
        """
        session_id = self._stored_session if session_id is None else session_id
        if session_id < 0:
            raise Exception('Session ID was not provided and no session has been created yet.')

        resp = requests.get(f'{self.url}/session/{session_id}')
        if resp.status_code == 200:
            json = resp.json()
            return json
        elif resp.status_code == 404:
            return {"error": "Server returned status 404: session not found."}
        else:
            raise Exception(f'response from server: {resp.status_code}')

    def edit_session(self, session_id: int = None, **kwargs):
        """
        Edits a session using the provided key-value pairs as attributes. Does not update any attributes that are not
        specifically specified in the provided parameters. Cannot update the session_id and there are no required
        attributes.
        :param session_id: A unique ID generated by datastore used to identify a particular session.
        :param kwargs: Refer to the datastore_microservice readme for a full list of attributes:
        https://github.com/hobstowler/AI-ML-Bitcoin-Trading-Bot/tree/main/datastore-microservice
        :return: The edited session with given session ID.
        """
        session_id = self._stored_session if session_id is None else session_id
        if session_id < 0:
            raise Exception('Session ID was not provided and no session has been created yet.')

        resp = requests.patch(f'{self.url}/session/{session_id}', json=kwargs)
        if resp.status_code == 200:
            json = resp.json()
            return json
        elif resp.status_code == 404:
            return {"error": "Server returned status 404: session not found."}
        else:
            raise Exception(f'response from server: {resp.status_code}')

    def delete_session(self, session_id: int = None):
        """
        Deletes the session with the given session ID. If the session can't be deleted or can't be found, this method
        returns false. Returns true if the session is successfully deleted.
        :param session_id: A unique ID generated by datastore used to identify a particular session.
        :return: True if the session was successfully deleted. False otherwise.
        """
        session_id = self._stored_session if session_id is None else session_id
        if session_id < 0:
            raise Exception('Session ID was not provided and no session has been created yet.')

        resp = requests.delete(f'{self.url}/session/{session_id}')
        if resp.status_code == 204:
            return True
        else:
            return False

    def get_session_transactions(self, session_id: int = None) -> list:
        """
        Returns a list of transactions for a session with the given session_id.
        :param session_id: A unique ID generated by datastore used to identify a particular session.
        :return: A list of transaction entities associated with the given session.
        """
        session_id = self._stored_session if session_id is None else session_id
        if session_id < 0:
            raise Exception('Session ID was not provided and no session has been created yet.')

        resp = requests.get(f'{self.url}/session/{session_id}/transaction')
        if resp.status_code == 200:
            json = resp.json()
            return json
        else:
            raise Exception(f'response from server: {resp.status_code}')

    def buy_crypto(self, step: int, amount: float, value: float, session_id: int = None, **kwargs) -> int:
        """
        Creates a "buy" transaction for the session with the given session ID. The step number of the session/episode,
        the amount of coins bought, and the total value of the coins that are being bought are required values. Any
        other non-required attributes for the Transaction entity should be passed via keyword argument.
        :param session_id: A unique ID generated by datastore used to identify a particular session. Should be acquired
        when creating a new session.
        :param step: the step number of the session from the beginning of the session.
        :param amount: The amount of coins traded.
        :param value: The value of the coins traded in USD.
        :return: The transaction_id generated by datastore.
        """
        session_id = self._stored_session if session_id is None else session_id
        if session_id < 0:
            raise Exception('Session ID was not provided and no session has been created yet.')

        kwargs.update({
            "session_id": session_id,
            "type": "buy",
            "step": step,
            "amount": amount,
            "value": value
        })
        resp = requests.post(f'{self.url}/session/{session_id}/transaction', json=kwargs)
        if resp.status_code == 201:
            id = resp.json()['id']
            return id
        else:
            raise Exception(f'response from server: {resp.status_code}')

    def sell_crypto(self, step: int, amount: float, value: float, session_id: int = None, **kwargs) -> int:
        """
        Creates a "sell" transaction for the session with the given session ID. The step number of the session/episode,
        the amount of coins bought, and the total value of the coins that are being bought are required values. Any
        other non-required attributes for the Transaction entity should be passed via keyword argument.
        :param session_id: A unique ID generated by datastore used to identify a particular session. Should be acquired
        when creating a new session.
        :param step: the step number of the session from the beginning of the session.
        :param amount: The amount of coins traded.
        :param value: The value of the coins traded in USD.
        :return: The transaction_id generated by datastore.
        """
        session_id = self._stored_session if session_id is None else session_id
        if session_id < 0:
            raise Exception('Session ID was not provided and no session has been created yet.')

        kwargs.update({
            "type": "sell",
            "step": step,
            "amount": amount,
            "value": value
        })
        resp = requests.post(f'{self.url}/session/{session_id}/transaction', json=kwargs)
        if resp.status_code == 201:
            id = resp.json()['id']
            return id
        else:
            raise Exception(f'response from server: {resp.status_code}')

    def get_transaction_by_id(self, transaction_id: int, session_id: int = None):
        session_id = self._stored_session if session_id is None else session_id
        if session_id < 0:
            raise Exception('Session ID was not provided and no session has been created yet.')

        resp = requests.get(f'{self.url}/session/{session_id}/transaction/{transaction_id}')
        if resp.status_code == 200:
            id = resp.json()
            return id
        else:
            raise Exception(f'response from server: {resp.status_code}')


    def delete_transaction(self, transaction_id: int, session_id: int = None):
        """
        Deletes the transaction for the given transaction_id under the given session_id.
        :param transaction_id: A unique ID generated by datastore used to identify a particular transaction.
        :param session_id: A unique ID generated by datastore used to identify a particular session.
        :return: True if the transaction was successfully deleted. False otherwise.
        """
        session_id = self._stored_session if session_id is None else session_id
        if session_id < 0:
            raise Exception('Session ID was not provided and no session has been created yet.')

        resp = requests.delete(f'{self.url}/session/{session_id}/transaction/{transaction_id}')
        if resp.status_code == 204:
            return True
        else:
            return False


if __name__ == '__main__':
    client = DatastoreWrapper('https://datastore-micro-dot-ai-ml-bitcoin-bot.uw.r.appspot.com/')
    sessions = client.get_all_sessions()
    print(sessions)
    session_id = sessions[0]['id']
    session = client.get_session_by_id(session_id)
    print(session)
    transaction_id = client.buy_crypto(25, 850.0, 11.0, session_id)
    transactions = client.get_session_transactions(session_id)
    print(transactions)
    print(client.get_transaction_by_id(transaction_id, session_id))
    print(client.delete_transaction(transaction_id, session_id))

    new_session_id = client.create_session(**{
        "session_name": "test session",
        "type": "test type",
        "starting_balance": 1000.0,
        "starting_coins": 10.0,
        "crypto_type": "test crypto"
    })
    print(client.get_session_by_id(new_session_id))
    print(client.delete_session(new_session_id))
