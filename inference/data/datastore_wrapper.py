import requests


class DatastoreWrapper():
    def __init__(self, url=None):
        if url is None:
            url = 'https://datastore-micro-dot-ai-ml-bitcoin-bot.uw.r.appspot.com/'
        self.url = url
        self._stored_session = -1

    def create_session(self, **kwargs) -> int:
        """
        Creates a new session entity with the provided keyword arguments.
        Returns the resulting session_id from datastore to use in later requests.
        Required keyword arguments and types:
            session_name : str
            type : str
            starting_balance : float
            starting_coins : float
            crypto_type : str
        Refer to README for full list of keyword arguments.
        :param kwargs: Session details to be sent in the request.
        :return: The session_id upon success.
        """
        # validate inputs
        if 'session_name' not in kwargs:
            raise Exception('Missing required "session_name" in kwargs.')
        if 'type' not in kwargs:
            raise Exception('Missing required "type" in kwargs.')
        if 'starting_balance' not in kwargs:
            raise Exception('Missing required "starting_balance" in kwargs.')
        if 'starting_coins' not in kwargs:
            raise Exception('Missing required "starting_coins" in kwargs.')
        if 'crypto_type' not in kwargs:
            raise Exception('Missing required "crypto_type" in kwargs.')

        resp = requests.post(f'{self.url}/session/', json=kwargs)
        if resp.status_code == 201:
            json = resp.json()
            self._stored_session = int(json['id'])
            return self._stored_session
        else:
            raise Exception(f'response from server: {resp.status_code}')

    def get_most_recent_session_id(self) -> int:
        """
        Returns the session id of the most recently created session or -1 if no session has been created with this
        instance of the Wrapper class.
        :return: The session id of the most recently created session.
        """
        return self._stored_session

    def get_all_sessions(self) -> list:
        """
        Returns all sessions from datatstore as a list. If a field has not been valued via POST or PATCH, it will be
        returned as None.
        :return: a list of session entities from datastore.
        """
        resp = requests.get(f'{self.url}/session')
        if resp.status_code == 200:
            json = resp.json()['sessions']
            return json
        else:
            raise Exception(f'response from server: {resp.status_code}')

    def get_session_by_id(self, session_id: int = None) -> dict:
        """
        Returns a session for a given session_id. Session_id can be obtained when creating a session or by searching
        the list of all sessions returned from get_all_sessions(). The DatastoreWrapper class will also store the
        session_id of most recently created session, which can be retrieved with the get_most_recent_session_id()
        method.
        :param session_id: A unique ID generated by datastore used to identify a particular session.
        :return: A session with the given session ID.
        """
        session_id = self._stored_session if session_id is None else session_id
        if session_id < 0:
            raise Exception('Session ID was not provided and no session has been created yet.')

        resp = requests.get(f'{self.url}/session/{session_id}')
        if resp.status_code == 200:
            json = resp.json()
            return json
        elif resp.status_code == 404:
            return {"error": "Server returned status 404: session not found."}
        else:
            raise Exception(f'response from server: {resp.status_code}')

    def edit_session(self, session_id: int = None, **kwargs):
        """
        Edits a session using the provided key-value pairs as attributes. Does not update any attributes that are not
        specifically specified in the provided parameters. Cannot update the session_id and there are no required
        attributes.
        :param session_id: A unique ID generated by datastore used to identify a particular session.
        :param kwargs: Refer to the datastore_microservice readme for a full list of attributes:
        https://github.com/hobstowler/AI-ML-Bitcoin-Trading-Bot/tree/main/datastore-microservice
        :return: The edited session with given session ID.
        """
        session_id = self._stored_session if session_id is None else session_id
        if session_id < 0:
            raise Exception('Session ID was not provided and no session has been created yet.')

        resp = requests.patch(f'{self.url}/session/{session_id}', json=kwargs)
        if resp.status_code == 200:
            json = resp.json()
            return json
        elif resp.status_code == 404:
            return {"error": "Server returned status 404: session not found."}
        else:
            raise Exception(f'response from server: {resp.status_code}')

    def delete_session(self, session_id: int = None):
        """
        Deletes the session with the given session ID. If the session can't be deleted or can't be found, this method
        returns false. Returns true if the session is successfully deleted.
        :param session_id: A unique ID generated by datastore used to identify a particular session.
        :return: True if the session was successfully deleted. False otherwise.
        """
        session_id = self._stored_session if session_id is None else session_id
        if session_id < 0:
            raise Exception('Session ID was not provided and no session has been created yet.')

        resp = requests.delete(f'{self.url}/session/{session_id}')
        if resp.status_code == 204:
            return True
        else:
            return False

    def get_session_transactions(self, session_id: int = None) -> list:
        """
        Returns a list of transactions for a session with the given session_id.
        To get around potential Datastore limitations, this method will make requests in batches until all transactions
        have been received.
        :param session_id: A unique ID generated by datastore used to identify a particular session.
        :return: A list of transaction entities associated with the given session.
        """
        print("Started getting datastore transactions")
        session_id = self._stored_session if session_id is None else session_id
        if session_id < 0:
            raise Exception('Session ID was not provided and no session has been created yet.')

        next_url = f'{self.url}/session/{session_id}/transaction'
        results = []
        print("Starting while loop for next url")
        while next_url:
            print("Running while loop")
            resp = requests.get(next_url)
            if resp.status_code == 200:
                json = resp.json()
                next_url = json['next']
                transactions = json['transactions']
                for transaction in transactions:
                    results.append(transaction)
            else:
                raise Exception(f'response from server: {resp.status_code}')
        print("Finished while loop")
        results.sort(key=lambda x: x['step'])
        print("Done getting datastore transactions")
        return results

    def create_transaction(self, step: int, transaction_type: str, session_id: int = None, **values) -> int:
        """
        Creates a transaction for the session with the given session ID. The step number of the session/episode,
        the transaction type, and at least one 'values' keyword argument. Values passed via the values parameter will be
        each be a point on a chart whose label is the key passed for the argument.
        :param session_id: A unique ID generated by datastore used to identify a particular session. Should be acquired
        when creating a new session.
        :param transaction_type: Type of transaction being created.
        :param step: the step number of the session from the beginning of the session.
        :param values: label/value pairs to be used in data visualization.
        :return: The transaction_id generated by datastore.
        """
        session_id = self._stored_session if session_id is None else session_id
        if session_id < 0:
            raise Exception('Session ID was not provided and no session has been created yet.')

        if len(values) == 0:
            raise Exception('No values passed.')

        value_string = ''
        for key, val in values.items():
            value_string += f'{key}={val},'
        value_string = value_string[:-1]

        data = {}
        data.update({
            "step": step,
            "type": transaction_type,
            "values": value_string
        })
        resp = requests.post(f'{self.url}/session/{session_id}/transaction', json=data)
        if resp.status_code == 201:
            id = resp.json()['id']
            return id
        else:
            raise Exception(f'response from server: {resp.status_code}')

    def get_transaction_by_id(self, transaction_id: int, session_id: int = None):
        """
        Returns the transaction for the specified transaction ID under the specified session ID
        :param transaction_id: A unique ID generated by datastore used to identify a particular transaction.
        :param session_id: A unique ID generated by datastore used to identify a particular session.
        :return: The requested transaction with details.
        """
        session_id = self._stored_session if session_id is None else session_id
        if session_id < 0:
            raise Exception('Session ID was not provided and no session has been created yet.')

        resp = requests.get(f'{self.url}/session/{session_id}/transaction/{transaction_id}')
        if resp.status_code == 200:
            id = resp.json()
            return id
        else:
            raise Exception(f'response from server: {resp.status_code}')


    def delete_transaction(self, transaction_id: int, session_id: int = None):
        """
        Deletes the transaction for the given transaction_id under the given session_id.
        :param transaction_id: A unique ID generated by datastore used to identify a particular transaction.
        :param session_id: A unique ID generated by datastore used to identify a particular session.
        :return: True if the transaction was successfully deleted. False otherwise.
        """
        session_id = self._stored_session if session_id is None else session_id
        if session_id < 0:
            raise Exception('Session ID was not provided and no session has been created yet.')

        resp = requests.delete(f'{self.url}/session/{session_id}/transaction/{transaction_id}')
        if resp.status_code == 204:
            return True
        else:
            return False


# if __name__ == '__main__':
#     client = DatastoreWrapper('https://datastore-micro-dot-ai-ml-bitcoin-bot.uw.r.appspot.com/')
#     sessions = client.get_all_sessions()
#     print(sessions)
#     session_id = sessions[0]['id']
#     session = client.get_session_by_id(session_id)
#     print(session)
#     transaction_id = client.buy_crypto(25, 850.0, 11.0, session_id)
#     transactions = client.get_session_transactions(session_id)
#     print(transactions)
#     print(client.get_transaction_by_id(transaction_id, session_id))
#     print(client.delete_transaction(transaction_id, session_id))

#     new_session_id = client.create_session(**{
#         "session_name": "test session",
#         "type": "test type",
#         "starting_balance": 1000.0,
#         "starting_coins": 10.0,
#         "crypto_type": "test crypto"
#     })
#     print(client.get_session_by_id(new_session_id))
#     print(client.delete_session(new_session_id))


if __name__ == '__main__':
    client = DatastoreWrapper()
    # Create a new session
    # session_id = client.create_session(**{
    #     "session_name": "Portfolio",
    #     "type": "inference",
    #     "starting_balance": 8322.8935,
    #     "starting_coins": 1.082,
    #     "crypto_type": "BTC",
    #     "model_name": "LSTM",
    # })

    # print(session_id)

    # Delete a session
    #print(client.delete_session(4917632511770624))

    #Delete all transactions
    for transaction in client.get_session_transactions(4920093460922368):
        client.delete_transaction(transaction['id'], 4920093460922368)

